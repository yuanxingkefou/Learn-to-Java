#红黑树（R-B Tree)

**特点**
* 1）每个节点是黑色或者是红色
* 2）根节点是黑色
* 3）每个叶子节点（NIL）（为空）是黑色
* 4）如果一个节点是红色的，那么它的子节点必须是黑色的
* 5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

**应用**

主要是用它来存储有序的数据，它的时间复杂度是O(lgn)；Java集合中的TreeSet和TreeMap，以及Linux虚拟内存的管理等

**基本操作**

**左旋**

![image](https://github.com/yuanxingkefou/Learn-to-Java/blob/master/Data-Algorithm/Algorithm/Left_Rotate.png)

对x进行左旋，意味着将x变成一个左节点

伪代码：
```
LEFT-ROTATE(T, x)  
 y ← right[x]            // 前提：这里假设x的右孩子为y。下面开始正式操作
 right[x] ← left[y]      // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子
 p[left[y]] ← x          // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x
 p[y] ← p[x]             // 将 “x的父亲” 设为 “y的父亲”
 if p[x] = nil[T]       
 then root[T] ← y                 // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点
 else if x = left[p[x]]  
           then left[p[x]] ← y    // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
           else right[p[x]] ← y   // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”
 left[y] ← x             // 将 “x” 设为 “y的左孩子”
 p[x] ← y                // 将 “x的父节点” 设为 “y”
```

**右旋**

![image](https://github.com/yuanxingkefou/Learn-to-Java/blob/master/Data-Algorithm/Algorithm/RIght_Rotate.png)

对y进行右旋，意味着将y变成一个右节点

伪代码：
```
RIGHT-ROTATE(T, y)  
 x ← left[y]             // 前提：这里假设y的左孩子为x。下面开始正式操作
 left[y] ← right[x]      // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子
 p[right[x]] ← y         // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y
 p[x] ← p[y]             // 将 “y的父亲” 设为 “x的父亲”
 if p[y] = nil[T]       
 then root[T] ← x                 // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点
 else if y = right[p[y]]  
           then right[p[y]] ← x   // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”
           else left[p[y]] ← x    // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”
 right[x] ← y            // 将 “y” 设为 “x的右孩子”
 p[y] ← x                // 将 “y的父节点” 设为 “x”
```

**添加**

* 1）将一颗红黑树当作一颗二叉查找树，将节点插入
* 2）将插入的节点着色为红色（这样不会违背特性五）
* 3）通过一系列的旋转或着色等操作，使之重新成为一颗红黑树

根据被插入节点的父节点的情况，可以划分为三种情况处理：

* 1.情况：被插入的节点是根节点     处理方法：直接把该节点涂为黑色
* 2.情况：被插入的节点的父节点是黑色    处理方法：什么也不需要做
* 3.情况：被插入的节点的父节点是红色，具体又有三种情况

现象说明        |     处理策略
---------------|----------------
当前节点的父节点是红色，叔叔节点也是红色|将父节点设为黑色，将叔叔节点设为黑色，将祖父节点设为红色，将祖父节点设为当前节点，之后继续操作
当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子|将父节点作为当前节点，以新的当前节点进行左旋
当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子|将父节点设为黑色，将祖父节点设为红色，以祖父节点为支点进行右旋

处理红黑树的核心思想：将红色的节点移到根节点，然后将根节点设为黑色，由下至上进行处理

**删除**

* 1.将红黑树当作一颗二叉查找树，将节点删除
  
  和常规二叉树中删除节点的方法是一样的，分三种情况：
  * 1）被删除节点没有儿子，那么直接将该节点删除就可以了
  * 2）被删除节点只有一个儿子，那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置
  * 3）被删除节点有两个儿子，那么，先找出它的后继节点，然后把它的后继节点的内容复制给该节点，之后删除后继节点，然后按上面两种情况操作

* 2.通过旋转和重新着色等一系列操作来修正该树，使之重新成为一颗红黑树

删除节点y后，x占据了y的位置，假设x包含一个额外的黑色，分为三种情况：

* 1）x是“红+黑”节点   处理：直接把x设为黑色
* 2）x是“黑+黑”节点，且x是根    处理：什么都不用做
* 3）x是“黑+黑”节点，且x不是根，有四种情况

情况说明                    |处理方法
----------------------------|-------------------
x的兄弟节点是红色|将x的兄弟节点设为黑色，将x的父节点设为红色，将x的父节点进行左旋，然后，重新设置x的兄弟节点为新的x节点
x的兄弟节点是黑色，x的兄弟节点的两个节点都是黑色|将x的兄弟节点设为红色，设置x的父节点为新的x节点
x的兄弟节点是黑色，x的兄弟节点的左孩子是红色，右孩子是黑色|将x兄弟节点的左孩子设为黑色，将x兄弟节点设为红色，对x的兄弟节点进行右旋，重新设置x的兄弟节点
x的兄弟节点是黑色，x的兄弟节点的右孩子是红色，左孩子任意颜色|将x父节点颜色赋值给x的兄弟节点，将x父节点设为黑色，将x兄弟节点的右子节点设为黑色，对x的父节点进行左旋，设置x为根节点




