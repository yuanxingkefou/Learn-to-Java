#多线程

**线程**：一个程序同时执行多个任务，通常，每个任务称为一个线程

**线程状态**：

*New（新创建）

当用new操作符创建一个新线程时，如new Thread(r),

*Runnable（可运行）

一旦调用start方法，线程就处于runnable状态

在任何给定时刻，一个可运行的线程可能正在运行，也可能没有运行

*Blocked（被堵塞）

当一个线程试图获取一个内部的对象锁时，而该锁被其他线程锁持有，则该线程进入堵塞状态

*Waiting（等待）

当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态

*Timed waiting（计时等待）

有几个方法有一个超时参数，调用它们导致进程进入计时等待

*Terminated（被终止）

1）因为run方法正常退出而自然死亡

2）因为一个没有捕获的异常终止了run方法而意外死亡

![image](https://github.com/yuanxingkefou/Learn-to-Java/blob/master/JavaSE/ThreadStatus.png)

**##线程属性**

*线程优先级

可以用setPriority方法提高或降低任何一个线程的优先级

*守护线程

可以通过调用t.setDaemon(true)；将线程转换为守护线程。守护线程的唯一用途是为其他线程提供服务，如计时线程

*未捕获异常处理器

**##同步**

竞争条件

锁对象lock()和unlock()

条件对象Condition

synchronized关键字

同步堵塞：
```
synchronized(obj)
{
    critical section
}
```

监视器

Volatile域：Volatile关键字为实力域的同步访问提供了一种免锁机制，如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的

final变量

**##堵塞队列**

![image]()

1）将队列当作线程管理工具来使用，使用put和take方法

2）当试图向满的队列中添加或从空的队列中移出元素时，add,remove和element抛出异常

3）在多线程程序中，使用offer,poll和peek作为替代

**##线程安全的集合**

高效的映射表，有序集和队列：ConsurrentHashMap,ConsurrentSkipListMap,ConcurrentSkipListSet,ConsurrentLinkedQueue

Runnable，Callable和Future

Runnable封装一个异步运行的任务，可以把它想象成一个没有参数和返回值的异步方法

Callable与Runnable类似，但是有返回值

Future保存异步计算的结果

**##执行器**

**线程池：**如果程序中创建了大量的生命期很短的线程，就可以使用线程池




