#Java内存区域与内存溢出异常

**##运行时数据区域**


数据区域         |   介绍                                | 生命周期               |抛出异常
----------------|---------------------------------------|----------------------|-------------------
程序计数器       | 当前线程所执行的字节码的行号指示器       | 线程私有              |无任何OutOfMemoryError
Java虚拟机栈     |描述的是方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储变量表，操作数栈，动作链接，方法出口等信息   |线程私有，与线程相同     |如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常;如果虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存，抛出OutofMemoryError异常 
本地方法栈       |为虚拟机使用到的Native方法服务           | 与Java虚拟机栈相似  |如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常;如果虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存，抛出OutofMemoryError异常                  
Java堆          |用来存放对象实例，是垃圾收集器管理的主要区域，因此也称为“GC堆”|所有线程共享，虚拟机启动时创建|如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError
方法区          |用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据|所有线程共享|当方法区无法满足内存分配需求时，将抛出OutOfMemoryError
运行时常量池     |方法区的一部分，用于存放Class文件中编译器生成的各种字面量和符号引用|与方法区一样|当常量池无法再申请到内存时，抛出OutOfMemoryError

**##HotSpot虚拟机对象在Java堆中对象分配，布局和访问**

**###对象的创建**

当虚拟机遇到一条new指令时，

1）执行类加载检查

2）为新生对象分配内存：将一块确定大小的内存从Java堆中划分出来。根据Java堆是否规整，可以采取指针碰撞，空闲列表两种方法

保证对象创建的原子性：

* 采用CAS配上失败重试的方式
* 采用本地线程分配缓冲(Thread Local Allocation Buffer,TLAB),用-XX:+/-UseTLAB参数来设定

3）将分配到的内存空间初始化为零值（不包括对象头）

4）对对象进行必要的信息设置，存放在对象头中

5）执行init方法，把对象按照程序员的意愿进行初始化

**###对象的内存布局**

对象在内存中存储的布局可以分为3块：

* 对象头：包括两部分。

第一部分用于存储对象自身的运行时数据，在32位和64位的虚拟机中分别为32bit，64bit，称为“Mark Word”。

另一部分是类型指针，即对象指向它的类元数据的指针

* 实例数据：对象真正存储的有效信息

* 对齐填充：起占位符的作用

**###对象的访问定位**

* 句柄访问：Java堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址

* 直接指针访问：reference中存储的直接就是对象地址

**##OutOfMemoryError异常**




